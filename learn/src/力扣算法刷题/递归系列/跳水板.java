package 力扣算法刷题.递归系列;

public class 跳水板 {
	
	/** 
	 * 题目：
	 *     你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。
	 *     你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。
	 *     
	 *     返回的长度需要从小到大排列
	 */
	
	/** 
	 * 示例：
	 *    输入：shorter = 1   longer = 2    k = 3
	 *    输出：[3,4,5,6]
	 *    
	 * 解释：可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。
	 */
	
	/** 
	 * 解题思路：
	 *       递归解法(超时)、记忆优化法(超时)、最优解法
	 *       首先考虑两种边界情况：
	 *       如果k=0，则不能建造任何跳水板，因此返回空数组。
	 *       如果shorter和longer相等，则建造的跳水板的长度是唯一的，都等于shorter x k,因此返回长度为1的数组，数组中的元素为 shorter X k
	 */
	
	/** 
	 * 解法一：数学（最优解法）
	 * 时间复杂度：O(k)，其中k是木板数量。短木板和长木板一共使用K块，一共有k+1种组合，对于每种组合都要计算跳水板的长度。
	 * 空间复杂度：O(1)。除了返回值以外，额外使用的空间复杂度为常数。
	 */
	public int[] divingBoard(int shorter, int longer, int k) {
		if(k == 0) {
			return new int[0];
		}
		if(shorter == longer) {
			return new int[] {shorter};
		}
		int[] lengths = new int[k+1];
		for(int i = 0; i <= k; i ++) {
			lengths[i] = shorter * (k - i) + longer * i;
		}
		return lengths;
	}

}
