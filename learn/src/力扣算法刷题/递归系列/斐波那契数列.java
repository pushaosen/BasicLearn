package 力扣算法刷题.递归系列;

public class 斐波那契数列 {
	
	/** 
	 * 题目：写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义
	 * 如下：
	 *     F(0) = 0,   F(1) = 1
	 *     F(N) = F(N - 1) + F(N - 2), 其中 N > 1
	 *     
	 *     斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
	 *     答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
	 */
	
	/** 
	 * 解题思路：
	 *       1、递归法：
	 *         原理：把f(n)问题的计算拆成f(n-1)和f(n-2)两个子问题的计算，并递归，以f(0)和f(1)为终止条件。
	 *         缺点：大量重复的递归计算，例如f(n)和f(n-1)两者向下递归需要各自计算f(n-2)的值。
	 *       2、记忆化递归法：
	 *         原理：在递归法的基础上，新建一个长度为n的数组，用于在递归时存储f(0)至f(n)的数字值，重复遇到某数字则直接从数组取用，
	 *             避免了重复的递归计算。
	 *         缺点：记忆化存储需要使用O(n)的额外空间。
	 *       3、动态规划
	 *         原理：以斐波那契数列性质f(n+1)=f(n)+f(n-1)为转移方程。
	 *         从计算效率、空间复杂度上看，动态规划是本题的最佳解法。
	 */
	
	/** 
	 * 解法一：动态规划
	 * 时间复杂度：O(N)，计算f(n)需要循环n次，每次循环内计算操作使用O(1)。
	 * 空间复杂度：O(1)，几个标志性变量使用常数大小的额外空间。
	 * 空间复杂度优化：由于dp列表第i项只与第i-1和第i-2项有关，因此只需要初始化三个整形变量sum，a，b，利用
	 *           辅助变量sum使a，b两数字交替前进即可(具体实现见代码)
	 *           节省了dp列表空间，因此空间复杂度降至O(1)。
	 */
	public int fib(int n) {
		int a = 0, b = 0, sum;
		for(int i = 0; i < n; i ++) {
			sum = (a+b) % 1000000007;
			a = b;
			b = sum;
		}
		return a;
	}

}
